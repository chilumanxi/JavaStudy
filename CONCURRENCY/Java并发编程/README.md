# 锁 #

非数组类型的对象头结构如下：
![](https://img-blog.csdnimg.cn/20190415101813830.png)

## 偏向锁 ##
JDK1.6提出的一种锁优化方式。核心思想是，如果程序没有竞争，则取消之前已经取得锁的同步操作。也就是说，当某一锁被线程获取后，就会进入偏向模式，当线程再次请求这个锁时，无需再进行相关的同步工作，从而节省了操作时间。如果在此期间有别的线程进行了请求，则锁退出偏向模式。

偏向锁在竞争比较少的情况下，能明显地提升系统性能，但是在有大量竞争的环境下，会导致持有锁的线程不停地切换，锁也很难一直保持在偏向模式，此时偏向锁有可能会降低系统性能，需要使用-XX:-UseBiasedLocking参数禁用。

当锁对象处于偏向模式时，对象头会记录获得锁的线程

`[JavaThread* | epoch | age | 1 | 01] `

## 轻量级锁 ##
如果偏向锁失败，Java虚拟机会让线程申请轻量级锁。

轻量级锁的对象头部Mark Word如下：

`[ptr | 00] locked`

轻量级锁加锁流程：

1. 在代码进入同步块时，如果同步对象锁的状态为无锁状态（锁标志位为“01”，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝，称之为Displaced Mark Word
2. 拷贝对象头中的Mark Word复制到锁记录中
3. 拷贝成功后，虚拟机将使用CAS（Compare And Swap，比较第一个和第二个参数的值，如果相同，则将第三个值赋值给第一个参数，该指令是原子性的，在其执行时不会中断别的指令）操作尝试将对象Mark Word更新为指向锁记录的指针，并将锁记录里的owner指针指向对象的Mark Word，如果成功，执行步骤4，否则执行步骤5
4. 成功以后，这个线程就有了该对象的锁，并且对象Mark Word的锁标志位设置为“00“，代表轻量级锁定状态，如下图所示：

![](https://img-blog.csdnimg.cn/20210323151110361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoaUx1TWFuWGk=,size_16,color_FFFFFF,t_70)

5. 如果更新失败了，说明多个线程竞争锁，轻量级锁要膨胀为重量级锁


## 重量级锁 ##
轻量级锁失败时，通过inflate()方法完成膨胀过程，获得对象的ObjectMonitor，有以下几种情况：

1. 已经是重量级状态，说明膨胀已经完成，直接返回
2. 如果是轻量级锁则需要进行膨胀操作
3. 如果是膨胀中状态，则进行忙等待
4. 如果是无锁状态则需要进行膨胀操作

对于轻量级锁的膨胀，有以下流程：

1. 调用omAlloc分配一个ObjectMonitor对象(以下简称monitor)，在omAlloc方法中会先从线程私有的monitor集合omFreeList中分配对象，如果omFreeList中已经没有monitor对象，则从JVM全局的gFreeList中分配一批monitor到omFreeList中。
2. 初始化monitor对象
3. 将状态设置为膨胀中（INFLATING）状态
4. 设置monitor的header字段为displaced mark word，owner字段为Lock Record，obj字段为锁对象
5. 设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象

对于无锁状态下膨胀，有以下流程：

1. 调用omAlloc分配一个ObjectMonitor对象(以下简称monitor)
2. 初始化monitor对象
3. 设置monitor的header字段为 mark word，owner字段为null，obj字段为锁对象
4. 设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象

膨胀完成后，使用enter()方法获得锁

1. 如果当前是无锁状态、锁重入、当前线程是之前持有轻量级锁的线程则进行简单操作后返回。
2. 先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销
3. 调用EnterI方法获得锁或阻塞

这里的自旋，指锁膨胀后，虚拟机希望线程可以尽快地进入临界区而避免被操作系统挂起而采取的一种手段。常见的方式是执行空循环。

## 锁消除 ##
锁消除是指Java虚拟机在进行JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，可以节省无意义的请求锁时间。

不可能存在共享资源竞争的锁存在于比如只有单线程的应用程序中，但是JDK内置的API比如Vector和StringBuffer内部有同步方法，在单线程的应用程序中，这些同步是没有必要的。

## 锁在应用层的优化思路 ##

1. 减少锁的持有时间，只对必要地方进行同步
2. 减小锁的粒度，使用ConcurrentHashMap,只要加入的表项不存放在同一个段中，则线程间便可以做到真正并行。但是问题是系统需要取得全局锁时，消耗的资源会比较多，虽然ConcurrentHashMap的put()方法很好的分离了锁，但是当试图访问时，需要同时获得所有段的锁。在高并发的情况下性能并不好。
3. 锁分离，典型案例是java.util.LinkedBlockingQueue，在实现中，其take()和put()方法是可以并行的，如果对整个队列进行独占锁的话，则take和put操作不能同时进行，这样只需要使take和take进行同步，put和put进行同步即可。
4. 锁粗化，锁粗化操作其实思想上与减少锁持有时间相反，因为如果对一个锁不断请求、同步和释放，本身也会消耗系统资源，不利于性能优化，所以可以将所有的锁操作粗化为一次锁操作，减少对锁的请求次数。如循环内每次都请求锁，可以改为循环前统一请求一次锁。

具体锁如何优化需要结合实际。


## 无锁 ##
无锁的概念利用的是CAS的思想，CAS(V,E,N)，只有期望值E和实际值V相同时，才会令V等于新值N，多个线程同时使用CAS操作一个变量的情况下，只有一个线程会成功，其他的线程均会失败，然后进行重试或者放弃。

无锁的好处在于没有锁竞争和线程间频繁调度引起的开销。

在java.util.concurrent.atomic包下，有一组使用无锁算法实现的原子操作类。

LongAdder类利用ConCurrentHashMap的思想，将热点数据分离，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。这样的效率比原子操作类更高。

具体详见代码Atomic.java


# 内存模型的特性 #
1. 原子性 原子指令不会打断其他指令的执行
2. 顺序性 操作顺序可能会影响程序结果，可以通过synchronized修饰方法来维持顺序性
3. 可见性 由于编译优化，部分变量会被高速缓存和寄存器存储，导致不能被别的线程即时访问发生的改变
4. 指令重排 