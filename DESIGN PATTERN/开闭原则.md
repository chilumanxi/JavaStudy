# 开闭原则

## 概念

开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。



## 示例

### 初始代码

AlertRule存储告警规则，Notification是告警通知类

`public class Alert {`
  `private AlertRule rule;`
  `private Notification notification;`

  `public Alert(AlertRule rule, Notification notification) {`
    `this.rule = rule;`
    `this.notification = notification;`
  `}`

  `public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {`
    `long tps = requestCount / durationOfSeconds;`
    `if (tps > rule.getMatchedRule(api).getMaxTps()) {`
      `notification.notify(NotificationEmergencyLevel.URGENCY, "...");`
    `}`
    `if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {`
      `notification.notify(NotificationEmergencyLevel.SEVERE, "...");`
    `}`
  `}`
`}`

该代码已经实现了监控TPS超标报警和报错数量报警，现在要求添加新的功能，实现每秒接口超时个数报警



### 修改代码

按照修改的逻辑，在check中新加参数和if判断条件。

`public class Alert {`
  `// ...省略AlertRule/Notification属性和构造函数...`

  `// 改动一：添加参数timeoutCount`
  `public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {`
    `long tps = requestCount / durationOfSeconds;`
    `if (tps > rule.getMatchedRule(api).getMaxTps()) {`
      `notification.notify(NotificationEmergencyLevel.URGENCY, "...");`
    `}`
    `if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {`
      `notification.notify(NotificationEmergencyLevel.SEVERE, "...");`
    `}`
    `// 改动二：添加接口超时处理逻辑`
    `long timeoutTps = timeoutCount / durationOfSeconds;`
    `if (timeoutTps > rule.getMatchedRule(api).getMaxTimeoutTps()) {`
      `notification.notify(NotificationEmergencyLevel.URGENCY, "...");`
    `}`
  `}`
`}`

该修改代码的问题是两条改动破坏了原有方法的入参，导致单元测试和调用该方法的地方都变得不可用，这就是有违对