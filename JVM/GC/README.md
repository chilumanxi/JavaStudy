# GC 垃圾回收 #
## 引用计数法(Reference Counting) ##
原理：对于一个对象A，当有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，A的引用计数器减1，当A的引用计数器为0时则对象A就不可再被使用

问题：
1. 无法处理循环引用问题
2. 引用计数器加1和减1操作会影响性能

## 标记清除法(Mark-Sweep) ##
标记清除法是现代垃圾回收算法的思想基础，分为标记和清除两个阶段

原理：标记阶段通过根节点标记所有从根节点开始的可达对象，因此，未被标记的对象就是未被引用的垃圾对象；清除阶段就清除掉所有未被标记的对象

问题：
可能产生空间碎片，不连续内存空间的工作效率要低于连续内存空间

## 复制算法(Copying) ##
原理：将原有的内存空间分为两块，每次只使用其中的一块。在进行垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后将正在使用的内存清空

优点：如果系统中垃圾对象比较多，复制算法需要复制的存活对象数量就会相对较少，复制效率会比较高，并且能保证新空间的内存连续性

问题：将系统内存折半，消耗大量内存空间。

实例：Java的年轻代使用的就是这样的算法，Eden区和S0把存活对象复制到S1中，然后将原空间清空。如果S0中有老对象和大对象，或者S1空间不足以存放，则直接存放入老年代

## 标记压缩法(Mark-Compact) ##
背景：复制算法的高效是建立在存活对象少，垃圾对象多的前提下的。这种情况多发生在年轻代，但是老年代大部分对象都是存活对象，如果依然复制，成本会很高。

原理：标记压缩算法和标记清除算法一样，首先从根节点开始，对所有可达对象做一次标记，但是之后并不进行清理工作，而是将标记的对象压缩到内存的一端，然后再清理标记以外的所有对象。

标记压缩算法最终效果等同于标记清除执行完后进行了一次内存碎片的整理，故又称为标记清除压缩法

## 分代算法(Generational Collecting) ##
原理：分代算法将内存区间根据对象的特点分为几块，根据每块内存区间的特点使用不同的回收算法，以提高垃圾回收的效率。

为了支持高频率的新生代回收，虚拟机可能使用一种叫做卡表（Card Table）的数据结构。卡表作为一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。

这样在新生代GC时，可以不用花大量时间扫描所有的老年代对象来确定每一个对象的引用关系，可以扫描卡表，只有卡表的标记为1时，才需要扫描给定区域的老年代对象，以寻找新生代对象位置。

通过这样的方式，可以大大提升新生代的回收速度。

## 分区算法 (Region) ##
原理：分区算法将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。

一般来说，相同条件下，堆空间越打，一次GC时间越长，为了更好控制GC的停顿时间(STW)，可以根据回收时间，合理回收若干个小空间，而不是一次性回收整个堆空间，从而减少一次GC所产生的停顿。

优点：可以控制一次回收小区间的数量。


## 串行回收器 ##
### 新生代串行回收器 ###
特点：
1. 仅使用单线程进行垃圾回收
2. 独占式的垃圾回收方式

在串行回收器进行垃圾回收时，Java应用程序中的线程都需要暂停工作，等待垃圾回收完成，这种现象称为"Stop-The-World"，会造成非常糟糕的用户体验，在实时性要求较高的应用场景中，往往是不能接受的。

但是新生代串行回收器使用复制算法，实现相对简单、逻辑处理特别高效且没有线程切换的开销。在诸如单CPU处理器等硬件平台不是特别优越的情况下，它的性能表现可以超过并行回收器和并发回收器。

使用-XX:+UseSerialGC参数可以指定使用新生代串行回收器或老年代串行回收器，当虚拟机在Client模式时，它是默认的垃圾回收器

### 老年代串行回收器 ###
老年代串行回收器也是一个串行的独占式的垃圾回收器。由于老年代垃圾回收通常会需要比新生代垃圾回收更长的时间，在堆空间较大的应用程序中，一旦老年代串行回收器启动，应用程序很可能会因此停顿较长的时间。

使用：
1. -XX:+UseSerialGC 新生代和老年代都使用串行回收器
2. -XX:+UseParNewGC （JDK9、JDK10已经删除，因为ParNew需要和CMS搭配工作，而CMS已经被G1代替，不再支持）：新生代使用ParNew回收器，老年代使用串行回收器
3. -XX:+UseParallelGC 新生代使用ParallelGC回收器，老年代使用串行回收器

## 并行回收器 ##
### 新生代ParNew回收器 ###
ParNew回收器是一个工作在新生代的垃圾回收器，它只是简单地将串行回收器多线程化，它的回收策略、算法及参数和新生代串行回收器相同。

使用：
1. -XX:+UseParNewGC （JDK9、JDK10已经删除，因为ParNew需要和CMS搭配工作，而CMS已经被G1代替，不再支持）：新生代使用ParNew回收器，老年代使用串行回收器
2. -XX:+UseConcMarkSweepGC（JDK9、JDK10不建议使用，建议使用默认的G1）：新生代使用ParNew回收器，老年代使用CMS回收器

ParNew回收器工作时线程数量可以使用-XX:ParallelGCThreads参数指定。一般最好与CPU数量相当，避免过多的线程影响垃圾回收性能。

默认情况下，CPU数量小于8时ParallelGCThreads等于CPU数量，CPU数量大于8时，ParallelGCThreads等于3+((5*CPU_Count)/8)

###新生代ParallelGC回收器 ###
ParallelGC回收器表面上看和ParNew回收器一样，都是使用复制算法，多线程、独占式的回收器。但是ParallelGC特别关注系统的吞吐量。

使用：
1. -XX:+UseParallelGC 新生代使用ParallelGC，老年代使用串行回收器
2. -XX:+UseParallelOldGC 新生代使用ParallelGC，老年代使用ParallelOldGC

ParallelGC回收器提供了两个重要的参数用于控制系统的吞吐量：
1. -XX:MaxGCPauseMillis 设置最大垃圾回收停顿时间，如果刻意降低此参数，会导致虚拟机使用一个较小的堆，导致垃圾回收频繁，增加总时间，降低吞吐量。
2. -XX:GCTimeRatio 设置吞吐量大小（取值0~100整数）。假设GCTimeRatio的值为n，那么系统将花费不超过1/(1+n)的时间进行垃圾回收。比如19代表垃圾回收时间不超过5%，默认值为99，即不超过1%

这两个参数是相反的两个参数，降低一个会增加另外一个

###老年代ParallelOldGC回收器 ###
ParallelOldGC使用标志压缩算法，在JDK1.6中才可以使用

-XX:+UseParallelOldGC 新生代使用ParallelGC，老年代使用ParallelOldGC，对吞吐量敏感的系统中可以考虑使用。

## CMS(Concurrent Mark Sweep)回收器 ##
CMS意为并发标记清除，使用的是标记清除算法，也是一个多线程并行的回收器。与ParallelGC和ParallelOldGC不同，CMS回收器主要关注系统停顿时间。



