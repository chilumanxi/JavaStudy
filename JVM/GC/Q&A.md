# 相关问题总结：#

## 1.STW是什么 ##
在串行回收器进行垃圾回收时，Java应用程序中的线程都需要暂停工作，等待垃圾回收完成，这种现象称为"Stop-The-World"。

## 2.新生代串行回收器使用什么算法，该算法有什么特点 ##
使用复制算法，实现相对简单、逻辑处理特别高效且没有现成切换的开销。\
复制算法是指将原有的内存空间分为两块，每次只使用其中的一块。在进行垃圾回收的时候，将正在使用的内存中的存活对象复制到未使用的内存块中，然后将正在使用的内存清空。\
如果系统中垃圾对象比较多，那么复制算法需要复制的存活对象就相对较少，复制效率会比较高，并且还可以保证新空间的连续性\
问题在于这样的做法等于将空间折半，会消耗大量的空间。

## 2.老年代串行回收器使用什么算法，该算法有什么特点 ##
老年代串行收集器使用的是标记压缩算法。\
标记压缩算法首先从根节点开始，对所有可达对象做一次标记，但是之后并不进行清理工作，而是将标记的对象压缩到内存的一端，然后再清理标记以外的所有对象。\
标记压缩算法最终效果等同于标记清除执行完后进行了一次内存碎片的整理，故又称为标记清除压缩法

## 4.ParNew GC和串行GC的关系 ##
ParNew回收器是一个工作在新生代的垃圾回收器，它只是简单地将串行回收器多线程化，它的回收策略、算法及参数和新生代串行回收器相同。

## 5.ParNew GC工作线程数量如何确定 ##
ParNew回收器工作时线程数量可以使用-XX:ParallelGCThreads参数指定。一般最好与CPU数量相当，避免过多的线程影响垃圾回收性能。\
默认情况下，CPU数量小于8时ParallelGCThreads等于CPU数量，CPU数量大于8时，ParallelGCThreads等于3+((5*CPU_Count)/8)

## 6.Parallel GC有什么特点##
Parallel GC在JDK8等版本中，是server模式JVM的默认GC选择，也被称为吞吐量优先的GC，算法和串行GC以及ParNew GC相同。\
Parallel Scavenge收集器主要关注的是应用的吞吐量，而不是STW。它提供了两个参数来精确地控制吞吐量\
-XX:MaxGCPauseMillis 设置最大垃圾回收停顿时间，如果刻意降低此参数，会导致虚拟机使用一个较小的堆，导致垃圾回收频繁，增加总时间，降低吞吐量。\
-XX:GCTimeRatio 设置吞吐量大小（取值0~100整数）。假设GCTimeRatio的值为n，那么系统将花费不超过1/(1+n)的时间进行垃圾回收。比如19代表垃圾回收时间不超过5%，默认值为99，即不超过1%


## 7.CMS工作步骤 ##
注意：CMS工作步骤是指在对老年代的垃圾回收，且只有初始标记和重新标记是STW的。\
1.初始标记(STW initial mark)在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。\
2.并发标记(Concurrent marking)这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。\
3.并发预清理(Concurrent precleaning)并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)，JVM会通过卡表的方式将变化区域标记为脏区。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。可以使用-XX:-CMSPrecleaningEnabled进行关闭，不进行预处理\
4.重新标记(STW remark)这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"跟对象"开始向下追溯，并处理对象关联。\
5.并发清理(Concurrent sweeping)清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。\
6.并发重置(Concurrent reset)这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。\

## 8.CMS采用标记清除算法是如何解决空间碎片问题的 ##
CMS不对堆空间整理压缩节约了垃圾回收的停顿时间，但也带来的堆空间的浪费。为了解决堆空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空间来为下次对象分配使用，而是把一些未分配的空间汇总成一个列表（空闲列表），当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来存储这个对象。\

## 9.CMS的缺点 ##
CMS的另一个缺点是它需要更大的堆空间。因为CMS标记阶段应用程序的线程还是在执行的，那么就会有堆空间继续分配的情况，为了保证在CMS回收完堆之前还有空间分配给正在运行的应用程序，必须预留一部分空间。也就是说，CMS不会在老年代满的时候才开始收集。相反，它会尝试更早的开始收集来避免上面提到的情况。默认当老年代使用68%的时候，CMS就开始行动了。可以通过– XX:CMSInitiatingOccupancyFraction=n 来设置这个阀值。
总得来说，CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。

## 10.CMS的默认启动的线程数 ##
CMS默认启动的回收线程数目是  (ParallelGCThreads + 3)/4)，如果你需要明确设定，可以通过-XX: ParallelCMSThreads =20来设定,其中 ParallelGCThreads是年轻代的并行收集线程数

## 11.G1 GC的特点 ##
属于JDK9的默认垃圾回收期。不再分配老年代、新生代，而是划分（通常是2048）个小堆区域。\
G1 GC不像其他垃圾回收器将所有识别到的垃圾全部清理，它具有一定的容忍度，优先清理垃圾较多的区域